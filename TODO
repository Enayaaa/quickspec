High-priority
-------------

Look into constraining rewrite rules so that the constraint is l >= r instead of l > r? This would mean that irrelevant variable laws like f x -> f a would become unconditional. Might reduce amount of case splitting too.

Simplify size expressions a bit more (e.g.: take out common factors, make sure that constant is always >= 0 by flipping sign)
Re-add disjunctions to constraint language (but use splitting for unification)

Make reducing-to-existing-term stuff more robust: whenever a term
simplifies to a term which we haven't generated, generate that term,
but only once we've come to the end of the current size.

Think about why we want to prefer equations with different schemas on
both sides. 1: simplification rules are nicer than random shuffling
about of stuff. 2: If we eliminate one equation because it reduces to
another, certain proofs may become harder. E.g. if the equation
reduces because of commutativity and we eliminate it, some proofs will
require commutativity that didn't before. Maybe then eliminating
schemas by simplifying using unorientable rules is something to avoid.

Introduce a "have seen" predicate which we define to be true on representative terms (this predicate is added to the rewrite system - or possibly not as we know it will never participate in critical pairs). This means that we can leave out terms as we like without affecting completeness too much (rule becomes: throw away a term t if seen(t) = true).

Look more into Moa's idea that any permutative law can be expressed as a permutative law over a single function (e.g. f x y = f y x)

Make sure that pruningTerm t < pruningTerm u <==> t < u!
Possible fix: add type axioms for Skolem constants.

Delay permutative laws until after all other laws of same size have been explored

Fix bug where ++ and zip generates loads of laws!

Fix bug where schemas are generated twice

Fix eta-expansion

Make it so that arbitrary instances are not compulsory

Implement big-universe/small-universe thing in a more principled way.
I don't think it works at the moment!

Make E-pruning work in a more principled way!

Generalise type variables after discovering equations!

Make main QuickSpec module export sensible stuff and clean up code

Add an explicit application constructor, use it when applying variables.

Make combinator example work (bug with polymorphic instantiation,
eta-expand laws about functions - perhaps just don't generate any
equalities on function types during pruning?)

Longer term
-----------

Allow the user to attach extra data to a constant.

Does the rewriting ordering need to be compatible with the term ordering?
Or would it be enough to keep a mapping from representatives to their normal forms?

Don't generate silly instances of schemas w/ commutative functions
Easy to avoid: just don't instantiate _+_ with two variables in the wrong order!
Any other commutativity-simplification will result in a different schema so already avoided
Exception: (e.g.) (_+_)+(_+_) - application of commutative function where both arguments have the same schema, but maybe we can deal with this later

Make timeouts a bit cleverer e.g. reduce test size
Instead of timeouts, allow the test evaluator to return a Maybe (if Nothing, throw out the test)

Fix heuristics so we get sum . map length = length . concat

Make main loop understand conditions in some way or other

Generalise to other things than equalities

Really take care of partiality.

Instantiate schemas in a smarter way. Also, try to avoid having to
look explicitly for laws with totally different variables on both sides.
E.g., if we have f x y = g x z, then we should also find f x y = g x k,
where k is an arbitrary constant - if we don't find this then we don't
need to search for f x y = g x z.

Teach E about application?
Alternatively, eta-expand all laws before passing on.

Teach crappy pruner about commutativity-like (schema-preserving) laws.
Or improve pruning.

Regexes: use Brzozowski derivatives to get a useful specification?

Print out definitions

If we have an equation where both sides contain a variable that doesn't appear on the other side, introduce (even if only internally) a new constant

Add "ask why an equation is not printed".

It isn't always true that if two schemas end up in the same class we
print an equation! It might be that we can't simplify the schema but
can simplify the one-variable case. Investigate how common this is and
perhaps try using the pruner to find the schema equation, to avoid
needlessly testing.

Try optimising the set of test cases - e.g., after completing each size,
analyse the test set and find the "most effective" set of test cases,
then move it to the front.

Cleanup ideas
-------------

Add typeclass of "stuff which contains variables" that we can e.g. alpha-rename.

Introduce a type constructor ForAll whose effect is to normalise all variables in the term.

Add useful function: "is this simpler for all values of these variables?"
Make the main pruning infrastructure check this?

Maybe add a type wrapper for preserving the original type of a polymorphic value
(store as original value + type subst??)

Instead of conGeneralValue/regeneralise nonsense, have a type
constructor "Mono a" which wraps its argument while having its Typed
instance unify all types.

Change Symbolic typeclass so you have Symbolic Tm instead of Symbolic
(Tm f v) (and lose Symbolic instance for types), or monomorphise the entire
pruning infrastructure.

Stuff for HipSpec
-----------------

Incrementally add functions to the signature?
Incrementally increase size?
(Rule? - "consider this size".
 Needs a notion of quiescence/ordering maybe?)
Alternatively, implement everything just by restarting.
